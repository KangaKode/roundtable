# {{ project_name }} Architecture

**Last Updated:** (update this when architecture changes)
**Status:** Canonical -- all code must conform to these rules

---

## Layering Rules

The codebase follows strict layered architecture with enforced dependency directions.

```
{% set layer_list = layers.split(',') | map('trim') | list -%}
{% for layer in layer_list -%}
{% if loop.first -%}
{{ layer }}/    (bottom layer -- types, config, persistence)
{% elif loop.last -%}
  {{ '  ' * (loop.index0) }}-> {{ layer }}/    (top layer -- UI, rendering, user interaction)
{% else -%}
  {{ '  ' * (loop.index0) }}-> {{ layer }}/    (middle layer)
{% endif -%}
{% endfor %}
```

### Additional Modules (outside the layer stack)

These modules are not part of the dependency chain above:

| Module | Imports From | Imported By | Purpose |
|--------|-------------|-------------|---------|
| `llm/` | `security/` | `orchestration/`, `agents/` | LLM client with prompt caching |
| `security/` | (none) | All modules | Prompt guard, validators, SSRF protection |
{% if include_api_gateway -%}
| `api/` | All modules | (external HTTP) | FastAPI gateway, routes, middleware |
{% endif -%}
{% if include_learning -%}
| `learning/` | `security/` | `api/`, `harness/` | Feedback, trust, preferences, RAG |
{% endif -%}
| `harness/` | `learning/` (optional) | `api/` | Session lifecycle |

### Dependency Direction Rules

These are enforced by `tests/test_architecture.py`:

{% for layer in layer_list -%}
{% set forbidden_layers = layer_list[loop.index0 + 1:] -%}
{% if forbidden_layers -%}
- **`{{ layer }}/`** CANNOT import from: {% for f in forbidden_layers %}`{{ f }}/`{% if not loop.last %}, {% endif %}{% endfor %}

{% endif -%}
{% endfor %}

### How to Fix a Dependency Violation

If `{{ layer_list[0] }}/foo.py` needs something defined in `{{ layer_list[-1] }}/bar.py`:

1. Extract the shared interface (dataclass, protocol, or utility) into `{{ layer_list[0] }}/`
2. Have both files import from `{{ layer_list[0] }}/`
3. Run `pytest tests/test_architecture.py` to verify

---

## Core Systems

### LLM Client (`llm/`)
Provider-agnostic wrapper supporting Anthropic, OpenAI, and Google. Auto-detects provider from environment variables. Uses `CacheablePrompt(system, context, user_message)` to separate stable prompt prefix from dynamic content -- the stable parts are cached by the provider for significant token savings.

**Key files:** `llm/client.py`

### Round Table (`orchestration/round_table.py`)
Full 4-phase multi-agent deliberation protocol:
- Phase 0: Strategy -- orchestrator plans before dispatching
- Phase 1: Independent -- agents analyze in parallel (separate context windows)
- Phase 2: Challenge -- cross-agent questioning with counter-evidence
- Phase 3: Synthesis + Voting -- consensus building with preserved minority views

Hub-and-spoke: agents report to orchestrator, never to each other directly. All intermediate results written to `artifacts/` for auditability.

### Chat Orchestrator (`orchestration/chat_orchestrator.py`)
Lightweight orchestrator-worker pattern for real-time interaction. Lead agent selects 1-3 relevant specialists via `AgentRouter`, consults them in parallel, cross-checks responses for agreement/disagreement, and synthesizes a user-facing response. Surfaces both views when specialists disagree. Escalates to full round table when confidence is low.

### Agent System (`agents/`)
- `example_agent.py` -- Reference implementation of `AgentProtocol`
- `remote.py` -- `RemoteAgent` adapter wrapping HTTP endpoints as `AgentProtocol`
- `registry.py` -- `AgentRegistry` managing local + remote agents with health checks

External agents implement 3 HTTP endpoints (`/analyze`, `/challenge`, `/vote`) in any language.

{% if include_api_gateway -%}
### API Gateway (`api/`)
FastAPI application with 10 route modules:
- `routes/round_table.py` -- Task submission and results
- `routes/chat.py` -- Chat messages with SSE streaming
- `routes/agents.py` -- Agent registry CRUD
- `routes/sessions.py` -- Session thread management
- `routes/webhooks.py` -- Async agent result delivery
- `routes/feedback.py` -- User feedback signals
- `routes/preferences.py` -- Learned preference management
- `routes/checkins.py` -- Permission-based adaptation gates
- `routes/health.py` -- Liveness, readiness, metrics
- `middleware/auth.py` -- API key authentication
- `middleware/rate_limit.py` -- Per-client rate limiting
{% endif -%}

### Security (`security/`)
- `prompt_guard.py` -- XML delimiter wrapping, injection pattern detection, content sanitization
- `validators.py` -- Input length, URL (anti-SSRF), identifier, list/dict size validation

Security is wired into every module that handles external input, not bolted on as an afterthought.

{% if include_learning -%}
### Learning System (`learning/`)
- `models.py` -- `FeedbackSignal`, `UserPreference`, `AgentTrustScore`, `CheckIn`
- `schema.py` -- SQLite schema (4 tables, 6 indexes)
- `feedback_tracker.py` -- Record and query accept/reject/modify signals
- `agent_trust.py` -- EMA-based trust scoring per agent
- `checkin_manager.py` -- Permission-based adaptation (never adapts silently)
- `user_profile.py` -- Aggregates preferences + trust into context bundles
- `global_profile.py` -- Cross-project identity at `~/.aiscaffold/`
- `graduation.py` -- Promotes stable patterns to global level (pluggable rules)
- `rag/` -- Vector store (ChromaDB + fallback), embeddings, semantic preference search
{% endif -%}

---

## State Management

| Tier | Persistence | Purpose | Example |
|------|------------|---------|---------|
| Ephemeral | None | Render-only | API result caches (LRU with TTL) |
| Session | Memory | Current session | Conversation history, thread state |
| Persistent | {% if persistence == 'sqlite' %}SQLite{% elif persistence == 'postgres' %}PostgreSQL{% else %}File-based{% endif %} | All user data | Feedback signals, preferences, trust scores |
| Global | `~/.aiscaffold/` | Cross-project | Global profile, graduated preferences |

**Critical rule:** Session state is a CACHE, not a source of truth. All data must persist to database.

---

## Design Decisions

- **FastAPI over Flask/Django** -- Async-native, automatic OpenAPI docs, Pydantic validation built in
- **SSE over WebSockets** -- Simpler protocol, works through proxies, sufficient for chat streaming
- **SQLite for dev, Postgres for prod** -- Zero-config locally, production-grade when deployed
- **ChromaDB optional** -- In-memory fallback for dev/testing, ChromaDB for persistent vector search
- **Adapter pattern for agents** -- `RemoteAgent` implements `AgentProtocol` over HTTP; round table/chat don't know the difference
- **String categories over enums** -- Signal types, preference types, and check-in types are strings so projects define their own taxonomy without modifying scaffold code
- **Security at boundaries** -- Every function that accepts external input sanitizes it; every SQL query is parameterized; every URL is validated
