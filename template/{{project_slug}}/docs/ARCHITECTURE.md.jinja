# {{ project_name }} Architecture

**Last Updated:** (update this when architecture changes)
**Status:** Canonical -- all code must conform to these rules

> **New here?** Start with the [Tutorial](TUTORIAL.md) or run `make demo` to see the system in action.

---

## Layering Rules

The codebase follows strict layered architecture with enforced dependency directions.

```
{% set layer_list = layers.split(',') | map('trim') | list -%}
{% for layer in layer_list -%}
{% if loop.first -%}
{{ layer }}/    (bottom layer -- types, config, persistence)
{% elif loop.last -%}
  {{ '  ' * (loop.index0) }}-> {{ layer }}/    (top layer -- UI, rendering, user interaction)
{% else -%}
  {{ '  ' * (loop.index0) }}-> {{ layer }}/    (middle layer)
{% endif -%}
{% endfor %}
```

### Additional Modules (outside the layer stack)

These modules are not part of the dependency chain above:

| Module | Imports From | Imported By | Purpose |
|--------|-------------|-------------|---------|
| `llm/` | `security/` | `orchestration/`, `agents/` | LLM client with prompt caching |
| `security/` | (none) | All modules | Prompt guard, validators, SSRF protection |
{% if include_api_gateway -%}
| `api/` | All modules | (external HTTP) | FastAPI gateway, routes, middleware |
{% endif -%}
{% if include_learning -%}
| `learning/` | `security/` | `api/`, `harness/` | Feedback, trust, preferences, RAG |
{% endif -%}
| `harness/` | `learning/` (optional) | `api/` | Session lifecycle |

### Dependency Direction Rules

These are enforced by `tests/test_architecture.py`:

{% for layer in layer_list -%}
{% set forbidden_layers = layer_list[loop.index0 + 1:] -%}
{% if forbidden_layers -%}
- **`{{ layer }}/`** CANNOT import from: {% for f in forbidden_layers %}`{{ f }}/`{% if not loop.last %}, {% endif %}{% endfor %}

{% endif -%}
{% endfor %}

### How to Fix a Dependency Violation

If `{{ layer_list[0] }}/foo.py` needs something defined in `{{ layer_list[-1] }}/bar.py`:

1. Extract the shared interface (dataclass, protocol, or utility) into `{{ layer_list[0] }}/`
2. Have both files import from `{{ layer_list[0] }}/`
3. Run `pytest tests/test_architecture.py` to verify

---

## Core Systems

### LLM Client (`llm/`)
Provider-agnostic wrapper supporting Anthropic, OpenAI, and Google. Auto-detects provider from environment variables. Uses `CacheablePrompt(system, context, user_message)` to separate stable prompt prefix from dynamic content -- the stable parts are cached by the provider for significant token savings.

**Key files:** `llm/client.py`

### Round Table (`orchestration/round_table.py`)
Full 4-phase multi-agent deliberation protocol:
- Phase 0: Strategy -- orchestrator plans before dispatching
- Phase 1: Independent -- agents analyze in parallel (separate context windows)
- Phase 2: Challenge -- cross-agent questioning with counter-evidence
- Phase 3: Synthesis + Voting -- consensus building with preserved minority views

Hub-and-spoke: agents report to orchestrator, never to each other directly. All intermediate results written to `artifacts/` for auditability.

### Chat Orchestrator (`orchestration/chat_orchestrator.py`)
Lightweight orchestrator-worker pattern for real-time interaction. Lead agent selects 1-3 relevant specialists via `AgentRouter`, consults them in parallel, cross-checks responses for agreement/disagreement, and synthesizes a user-facing response. Surfaces both views when specialists disagree. Escalates to full round table when confidence is low.

### Agent System (`agents/`)
- `example_agent.py` -- Reference implementation of `AgentProtocol`
- `remote.py` -- `RemoteAgent` adapter wrapping HTTP endpoints as `AgentProtocol`
- `registry.py` -- `AgentRegistry` managing local + remote agents with health checks
- `core/` -- Five core safety agents (auto-included in every round table):
  - `skeptic.py` -- Devil's advocate: challenges assumptions, demands evidence, flags logical fallacies
  - `quality.py` -- Completeness checker: tracks requirement coverage, flags gaps in scope
  - `evidence.py` -- Claim verifier: grades evidence strength, flags speculation presented as fact
  - `fact_checker_agent.py` -- Challenges speculation language in deliberation, explains why it's problematic
  - `citation_agent.py` -- Enforces evidence level tagging (VERIFIED/CORROBORATED/INDICATED/POSSIBLE)

Core agents are meta-agents that evaluate *how well* the analysis was done, not *what* was analyzed. They participate automatically unless `include_core_agents=False` is set in `RoundTableConfig`. This is a deliberate opt-out -- the default is safety-on.

### Evidence Enforcement Pipeline (`enforcement/`)
- `fact_checker.py` -- Scans for banned patterns: speculation ("probably"), opinion ("I think"), hedging ("seems to"), fake confidence ("90% confident")
- `evidence_levels.py` -- Validates VERIFIED/CORROBORATED/INDICATED/POSSIBLE tag format
- `citation_validator.py` -- Checks cited sources exist (pluggable SourceRegistry)
- `math_verifier.py` -- Validates numeric claims against ground truth (pluggable GroundTruthProvider)
- `pipeline.py` -- Orchestrates all validators with reject-and-rewrite behavior

The pipeline runs after Phase 1 (analysis) and before Phase 2 (challenge). Rejected responses get a correction prompt and are retried up to 2 times. Disable with `enforce_evidence=False` in `RoundTableConfig`

External agents implement 3 HTTP endpoints (`/analyze`, `/challenge`, `/vote`) in any language.

{% if include_api_gateway -%}
### API Gateway (`api/`)
FastAPI application with 10 route modules:
- `routes/round_table.py` -- Task submission and results
- `routes/chat.py` -- Chat messages with SSE streaming
- `routes/agents.py` -- Agent registry CRUD
- `routes/sessions.py` -- Session thread management
- `routes/webhooks.py` -- Async agent result delivery
- `routes/feedback.py` -- User feedback signals
- `routes/preferences.py` -- Learned preference management
- `routes/checkins.py` -- Permission-based adaptation gates
- `routes/health.py` -- Liveness, readiness, metrics
- `middleware/auth.py` -- API key authentication
- `middleware/rate_limit.py` -- Per-client rate limiting
{% endif -%}

### Security (`security/`)
- `prompt_guard.py` -- XML delimiter wrapping, injection pattern detection, content sanitization
- `validators.py` -- Input length, URL (anti-SSRF), identifier, list/dict size validation

Security is wired into every module that handles external input, not bolted on as an afterthought.

{% if include_learning -%}
### Learning System (`learning/`)
- `models.py` -- `FeedbackSignal`, `UserPreference`, `AgentTrustScore`, `CheckIn`
- `schema.py` -- SQLite schema (4 tables, 6 indexes)
- `feedback_tracker.py` -- Record and query accept/reject/modify signals
- `agent_trust.py` -- EMA-based trust scoring per agent
- `checkin_manager.py` -- Permission-based adaptation (never adapts silently)
- `user_profile.py` -- Aggregates preferences + trust into context bundles
- `global_profile.py` -- Cross-project identity at `~/.aiscaffold/`
- `graduation.py` -- Promotes stable patterns to global level (pluggable rules)
- `rag/` -- Vector store (ChromaDB + fallback), embeddings, semantic preference search
- `rag/transcript_indexer.py` -- Indexes round table results for semantic search over past deliberations
{% endif -%}

---

## State Management

| Tier | Persistence | Purpose | Example |
|------|------------|---------|---------|
| Ephemeral | None | Render-only | API result caches (LRU with TTL) |
| Session | Memory | Current session | Conversation history, thread state |
| Persistent | {% if persistence == 'sqlite' %}SQLite{% elif persistence == 'postgres' %}PostgreSQL{% else %}File-based{% endif %} | All user data | Feedback signals, preferences, trust scores |
| Global | `~/.aiscaffold/` | Cross-project | Global profile, graduated preferences |

**Critical rule:** Session state is a CACHE, not a source of truth. All data must persist to database.

---

## Design Decisions

- **FastAPI over Flask/Django** -- Async-native, automatic OpenAPI docs, Pydantic validation built in
- **SSE over WebSockets** -- Simpler protocol, works through proxies, sufficient for chat streaming
- **SQLite for dev, Postgres for prod** -- Zero-config locally, production-grade when deployed
- **ChromaDB optional** -- In-memory fallback for dev/testing, ChromaDB for persistent vector search
- **Adapter pattern for agents** -- `RemoteAgent` implements `AgentProtocol` over HTTP; round table/chat don't know the difference
- **String categories over enums** -- Signal types, preference types, and check-in types are strings so projects define their own taxonomy without modifying scaffold code
- **Security at boundaries** -- Every function that accepts external input sanitizes it; every SQL query is parameterized; every URL is validated
- **Multi-tenancy ready** -- `AuthContext` propagates `tenant_id` to all routes; `project_id` in the data layer maps to tenant isolation; agent `visibility` controls cross-tenant access. Defaults to single-tenant (everything is `"default"`) when not configured

---

## Multi-Tenancy (Structural)

The scaffold includes structural primitives for multi-tenancy. Single-tenant deployments use the defaults and ignore these fields entirely.

### AuthContext

`verify_api_key()` returns an `AuthContext` dataclass (not a raw string):

```python
@dataclass
class AuthContext:
    api_key: str | None = None
    user_id: str = "anon"
    tenant_id: str = "default"
```

All routes receive this context. To add multi-tenancy, extract `tenant_id` from a JWT, custom header, or API key lookup instead of hardcoding `"default"`.

### Data Isolation

The learning system (feedback, trust, preferences) uses `project_id` in every table. Map `auth.tenant_id` to `project_id` in route handlers to achieve tenant-scoped data.

### Agent Visibility

`AgentEntry` has `visibility` (`public`, `team`, `private`) and `tenant_id` fields. Use `registry.list_for_tenant(auth.tenant_id)` to filter agents by visibility rules:

- `public`: visible to all tenants
- `team`: visible only to the registering tenant
- `private`: visible only to the registering user

### Session Isolation

Chat sessions are keyed by `{tenant_id}:{user_id}:{session_id}`, preventing cross-tenant session access
